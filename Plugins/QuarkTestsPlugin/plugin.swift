//
//  File.swift
//  Quark
//
//  Created by Yeskendir Salgara on 15/05/2025.
//

import PackagePlugin
import Foundation

@main
struct QuarkTestsPlugin: BuildToolPlugin {
    func createBuildCommands(context: PluginContext, target: Target) async throws -> [Command] {
        print("[QuarkTestsPlugin] Plugin started for target: \(target.name)")
        
        // Get the test target that's using this plugin
        guard let testTarget = target as? SourceModuleTarget else {
            print("[QuarkTestsPlugin] Target is not a source module target")
            return []
        }
        
        // Find all targets that this test target depends on
        let testedTargets = findTestedTargets(in: context.package, for: testTarget)
        
        let targetNames = testedTargets.compactMap { $0 as? SourceModuleTarget }.map { $0.name }
        print("[QuarkTestsPlugin] Found tested targets: \(targetNames.joined(separator: ", "))")
        
        // Generate tests in the plugin's work directory
        let outputDir = context.pluginWorkDirectory.appending("GeneratedTests")
        try FileManager.default.createDirectory(at: URL(fileURLWithPath: outputDir.string), withIntermediateDirectories: true)
        
        var commands: [Command] = []
        
        // Create a test file that will import all generated tests
        let testIndexContent = generateTestIndex(for: testedTargets)
        let testIndexPath = outputDir.appending("GeneratedTestsIndex.swift")
        try testIndexContent.write(to: URL(fileURLWithPath: testIndexPath.string), atomically: true, encoding: .utf8)
        
        // Add the index file to the output files
        commands.append(
            .buildCommand(
                displayName: "Generate tests index",
                executable: .init("/bin/echo"),
                arguments: ["Generated tests index"],
                outputFiles: [testIndexPath]
            )
        )
        
        // Scan files in all tested targets
        for testedTarget in testedTargets {
            guard let sourceTarget = testedTarget as? SourceModuleTarget else { continue }
            
            print("[QuarkTestsPlugin] Scanning files in target: \(sourceTarget.name)")
            
            for file in sourceTarget.sourceFiles(withSuffix: ".swift") {
                print("[QuarkTestsPlugin] Checking file: \(file.url.path)")
                let content = try String(contentsOfFile: file.url.path)
                
                // Look for both the macro and its expanded form
                guard content.contains("@TrackPerformance") else { continue }
                
                print("[QuarkTestsPlugin] Found performance tracking in: \(file.url.lastPathComponent)")
                
                let viewName = file.url.deletingPathExtension().lastPathComponent
                let testFilePath = outputDir.appending("\(viewName)PerformanceTests.swift")
                let testContent = generateTestContent(for: viewName, target: sourceTarget.name)
                
                try testContent.write(to: URL(fileURLWithPath: testFilePath.string), atomically: true, encoding: .utf8)
                print("[QuarkTestsPlugin] Generated test: \(testFilePath.string)")
                
                // Add the generated test file to the output files
                commands.append(
                    .buildCommand(
                        displayName: "Generate performance test for \(viewName)",
                        executable: .init("/bin/echo"),
                        arguments: ["Generated test for \(viewName)"],
                        outputFiles: [testFilePath]
                    )
                )
            }
        }
        
        return commands
    }
    
    private func generateTestIndex(for targets: [Target]) -> String {
        """
        import XCTest
        import SwiftUI
        
        // This file is automatically generated by QuarkTestsPlugin
        
        // This ensures all tests are included in the test target
        final class GeneratedTestsIndex: XCTestCase {
            func testGeneratedTestsAreIncluded() {
                XCTAssertTrue(true, "This test ensures all generated tests are included in the test target")
            }
        }
        """
    }
    
    private func findTestedTargets(in package: Package, for testTarget: SourceModuleTarget) -> [Target] {
        var testedTargets: [Target] = []
        
        // Get all dependencies of the test target
        for dependency in testTarget.dependencies {
            switch dependency {
            case .target(let target):
                // Find the target in the package
                if let target = package.targets.first(where: { $0.name == target.name }) {
                    testedTargets.append(target)
                }
            case .product(let target):
                // Find the product in the package
                if let product = package.products.first(where: { $0.name == target.name }),
                   let target = package.targets.first(where: { $0.name == product.name }) {
                    testedTargets.append(target)
                }
            @unknown default:
                assertionFailure("Didn't expect to have dependency \(dependency)")
            }
        }
        
        return testedTargets
    }
    
    func generateTestContent(for viewName: String, target: String) -> String {
        """
        import XCTest
        import SwiftUI
        @testable import \(target)
        @testable import Quark
        
        @MainActor
        final class \(viewName)PerformanceTests: XCTestCase, Sendable {
            typealias ViewType = \(viewName)
            var view: ViewType!
            var hostingController: UIHostingController<ViewType>!
            
            override func setUp() {
                super.setUp()
                // Initialize view without parameters
                view = ViewType()
                hostingController = UIHostingController(rootView: view)
                _ = hostingController.view // Force view load
            }
            
            override func tearDown() {
                view = nil
                hostingController = nil
                super.tearDown()
            }
            
            func testViewInitialization() {
                XCTAssertNotNil(view, "View should be initialized")
                XCTAssertNotNil(hostingController, "Hosting controller should be initialized")
                XCTAssertNotNil(hostingController.view, "View should be loaded")
            }
            
            func testPerformanceMetadata() {
                // Access performance metadata through the view's type
                let metadata = ViewType.performanceMetadata
                XCTAssertFalse(metadata.isEmpty, "Performance metadata should not be empty")
                
                // Print metadata for debugging
                print("Performance Metadata for \(viewName):")
                for (id, info) in metadata {
                    print("- View ID: \\(id)")
                    if let deps = info["deps"] as? [String] {
                        print("  Dependencies: \\(deps)")
                    }
                    if let viewType = info["viewType"] as? String {
                        print("  View Type: \\(viewType)")
                    }
                    if let isContainer = info["isContainer"] as? Bool {
                        print("  Is Container: \\(isContainer)")
                    }
                }
            }
            
            func testDependencyTracking() {
                // Access tracked dependencies through the view's type
                let dependencies = ViewType.trackedDependencies
                XCTAssertFalse(dependencies.isEmpty, "Tracked dependencies should not be empty")
                
                // Print dependencies for debugging
                print("Tracked Dependencies for \(viewName):")
                for dep in dependencies {
                    print("- \\(dep)")
                }
            }
            
            func testUnnecessaryRecomputation() {
                // Get all dependencies
                let dependencies = ViewType.trackedDependencies
                
                // For each dependency
                for dep in dependencies {
                    // Reset test context
                    TestContext.shared.reset()
                    
                    // Trigger the dependency
                    let triggerName = "trigger\\(dep.name.prefix(1).uppercased() + dep.name.dropFirst())"
                    if let triggerMethod = view.value(forKey: triggerName) as? () -> Void {
                        triggerMethod()
                    }
                    
                    // Get recomputation counts
                    let recomputeCounts = TestContext.shared.recomputeCounts
                    
                    // For each view that recomputed
                    for (viewId, info) in recomputeCounts {
                        // Get the view's metadata
                        let metadata = ViewType.performanceMetadata[viewId] ?? [:]
                        let deps = metadata["deps"] as? [String] ?? []
                        
                        // Check if this view should have recomputed
                        XCTAssertTrue(deps.contains(dep.name), 
                                    "View '\\(viewId)' at \\(metadata["file"] ?? "unknown"):\\(metadata["line"] ?? 0) recomputed unnecessarily when \\(dep.name) changed")
                    }
                }
            }
            
            func testDependencyIsolation() {
                // Get all dependencies
                let dependencies = ViewType.trackedDependencies
                
                // For each dependency
                for dep in dependencies {
                    // Reset test context
                    TestContext.shared.reset()
                    
                    // Trigger the dependency
                    let triggerName = "trigger\\(dep.name.prefix(1).uppercased() + dep.name.dropFirst())"
                    if let triggerMethod = view.value(forKey: triggerName) as? () -> Void {
                        triggerMethod()
                    }
                    
                    // Get recomputation counts
                    let recomputeCounts = TestContext.shared.recomputeCounts
                    
                    // For each view that recomputed
                    for (viewId, info) in recomputeCounts {
                        // Get the view's metadata
                        let metadata = ViewType.performanceMetadata[viewId] ?? [:]
                        let deps = metadata["deps"] as? [String] ?? []
                        
                        // Verify that only views depending on this dependency recomputed
                        if !deps.contains(dep.name) {
                            XCTFail("View '\\(viewId)' at \\(metadata["file"] ?? "unknown"):\\(metadata["line"] ?? 0) should not recompute when \\(dep.name) changes")
                        }
                    }
                }
            }
        }
        """
    }
}
