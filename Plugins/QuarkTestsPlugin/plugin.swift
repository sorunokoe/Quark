//
//  File.swift
//  Quark
//
//  Created by Yeskendir Salgara on 15/05/2025.
//

import PackagePlugin
import Foundation

@main
struct QuarkTestsPlugin: BuildToolPlugin {
    func createBuildCommands(context: PluginContext, target: Target) async throws -> [Command] {
        print("[QuarkTestsPlugin] Plugin started for target: \(target.name)")
        
        // Get the test target that's using this plugin
        guard let testTarget = target as? SourceModuleTarget else {
            print("[QuarkTestsPlugin] Target is not a source module target")
            return []
        }
        
        // Find all targets that this test target depends on
        let testedTargets = findTestedTargets(in: context.package, for: testTarget)
        
        let targetNames = testedTargets.compactMap { $0 as? SourceModuleTarget }.map { $0.name }
        print("[QuarkTestsPlugin] Found tested targets: \(targetNames.joined(separator: ", "))")
        
        // Generate tests in the plugin's work directory
        let outputDir = context.pluginWorkDirectory.appending("GeneratedTests")
        try FileManager.default.createDirectory(at: URL(fileURLWithPath: outputDir.string), withIntermediateDirectories: true)
        
        var commands: [Command] = []
        
        // Create a test file that will import all generated tests
        let testIndexContent = generateTestIndex(for: testedTargets)
        let testIndexPath = outputDir.appending("GeneratedTestsIndex.swift")
        try testIndexContent.write(to: URL(fileURLWithPath: testIndexPath.string), atomically: true, encoding: .utf8)
        
        // Add the index file to the output files
        commands.append(
            .buildCommand(
                displayName: "Generate tests index",
                executable: .init("/bin/echo"),
                arguments: ["Generated tests index"],
                outputFiles: [testIndexPath]
            )
        )
        
        // Scan files in all tested targets
        for testedTarget in testedTargets {
            guard let sourceTarget = testedTarget as? SourceModuleTarget else { continue }
            
            print("[QuarkTestsPlugin] Scanning files in target: \(sourceTarget.name)")
            
            for file in sourceTarget.sourceFiles(withSuffix: ".swift") {
                print("[QuarkTestsPlugin] Checking file: \(file.url.path)")
                let content = try String(contentsOfFile: file.url.path)
                
                // Look for both the macro and its expanded form
                guard content.contains("@TrackPerformance") else { continue }
                
                print("[QuarkTestsPlugin] Found performance tracking in: \(file.url.lastPathComponent)")
                
                let viewName = file.url.deletingPathExtension().lastPathComponent
                let testFilePath = outputDir.appending("\(viewName)PerformanceTests.swift")
                let testContent = generateTestContent(for: viewName, target: sourceTarget.name)
                
                try testContent.write(to: URL(fileURLWithPath: testFilePath.string), atomically: true, encoding: .utf8)
                print("[QuarkTestsPlugin] Generated test: \(testFilePath.string)")
                
                // Add the generated test file to the output files
                commands.append(
                    .buildCommand(
                        displayName: "Generate performance test for \(viewName)",
                        executable: .init("/bin/echo"),
                        arguments: ["Generated test for \(viewName)"],
                        outputFiles: [testFilePath]
                    )
                )
            }
        }
        
        return commands
    }
    
    private func generateTestIndex(for targets: [Target]) -> String {
        """
        import XCTest
        import SwiftUI
        
        // This file is automatically generated by QuarkTestsPlugin
        
        // This ensures all tests are included in the test target
        final class GeneratedTestsIndex: XCTestCase {
            func testGeneratedTestsAreIncluded() {
                XCTAssertTrue(true, "This test ensures all generated tests are included in the test target")
            }
        }
        """
    }
    
    private func findTestedTargets(in package: Package, for testTarget: SourceModuleTarget) -> [Target] {
        var testedTargets: [Target] = []
        
        // Get all dependencies of the test target
        for dependency in testTarget.dependencies {
            switch dependency {
            case .target(let target):
                // Find the target in the package
                if let target = package.targets.first(where: { $0.name == target.name }) {
                    testedTargets.append(target)
                }
            case .product(let target):
                // Find the product in the package
                if let product = package.products.first(where: { $0.name == target.name }),
                   let target = package.targets.first(where: { $0.name == product.name }) {
                    testedTargets.append(target)
                }
            @unknown default:
                assertionFailure("Didn't expect to have dependency \(dependency)")
            }
        }
        
        return testedTargets
    }
    
    func generateTestContent(for viewName: String, target: String) -> String {
        """
        import XCTest
        import SwiftUI
        @testable import \(target)
        @testable import Quark
        
        @MainActor
        final class \(viewName)PerformanceTests: XCTestCase, Sendable {
            typealias ViewType = \(viewName)
            var view: ViewType!
            var hostingController: UIHostingController<ViewType>!
            
            override func setUp() {
                super.setUp()
                // Initialize view without parameters
                view = ViewType()
                hostingController = UIHostingController(rootView: view)
                _ = hostingController.view // Force view load
            }
            
            override func tearDown() {
                view = nil
                hostingController = nil
                super.tearDown()
            }
            
            func testViewInitialization() {
                XCTAssertNotNil(view, "View should be initialized")
                XCTAssertNotNil(hostingController, "Hosting controller should be initialized")
                XCTAssertNotNil(hostingController.view, "View should be loaded")
            }
            
            func testInitialState() {
                // Test that the switch is initially checked (true)
                let mirror = Mirror(reflecting: view)
                if let switchChecked = mirror.children.first(where: { $0.label == "switchChecked" })?.value as? Bool {
                    XCTAssertTrue(switchChecked, "Switch should be initially checked")
                } else {
                    XCTFail("Could not find switchChecked property")
                }
            }
            
            func testSwitchToggle() {
                // Reset test context
                TestContext.shared.reset()
                
                // Toggle the switch
                let mirror = Mirror(reflecting: view)
                if let child = mirror.children.first(where: { $0.label == "switchChecked" }) {
                    if var value = child.value as? Bool {
                        value.toggle()
                        if let keyPath = try? KeyPath<ViewType, Bool>("switchChecked") {
                            view[keyPath: keyPath] = value
                        }
                    }
                }
                
                // Wait for UI update
                RunLoop.current.run(until: Date(timeIntervalSinceNow: 0.1))
                
                // Verify switch state changed
                let updatedMirror = Mirror(reflecting: view)
                if let switchChecked = updatedMirror.children.first(where: { $0.label == "switchChecked" })?.value as? Bool {
                    XCTAssertFalse(switchChecked, "Switch should be toggled to unchecked")
                } else {
                    XCTFail("Could not find switchChecked property after toggle")
                }
                
                // Check which views recomputed
                let recomputeCounts = TestContext.shared.recomputeCounts
                XCTAssertFalse(recomputeCounts.isEmpty, "Some views should have recomputed")
                
                // Print recomputation details for debugging
                print("Recomputation Details:")
                for (viewId, info) in recomputeCounts {
                    print("- View ID: \\(viewId)")
                    print("  Count: \\(info.count)")
                    print("  File: \\(info.file)")
                    print("  Line: \\(info.line)")
                }
            }
            
            func testViewDependencies() {
                // Access tracked dependencies
                let dependencies = ViewType.trackedDependencies
                XCTAssertFalse(dependencies.isEmpty, "View should have tracked dependencies")
                
                // Verify switchChecked is tracked
                let hasSwitchChecked = dependencies.contains { dep in
                    dep.name == "switchChecked" && dep.type == "Bool"
                }
                XCTAssertTrue(hasSwitchChecked, "switchChecked should be tracked as a dependency")
                
                // Print dependencies for debugging
                print("Tracked Dependencies:")
                for dep in dependencies {
                    print("- Name: \\(dep.name)")
                    print("  Type: \\(dep.type)")
                    print("  Wrapper: \\(dep.wrapper)")
                }
            }
        }
        """
    }
}
