//
//  File.swift
//  Quark
//
//  Created by Yeskendir Salgara on 15/05/2025.
//

import PackagePlugin
import Foundation

@main
struct QuarkTestsPlugin: BuildToolPlugin {
    func createBuildCommands(context: PluginContext, target: Target) async throws -> [Command] {
        print("[QuarkTestsPlugin] Plugin started for target: \(target.name)")
        
        // Get the test target that's using this plugin
        guard let testTarget = target as? SourceModuleTarget else {
            print("[QuarkTestsPlugin] Target is not a source module target")
            return []
        }
        
        // Find all targets that this test target depends on
        let testedTargets = findTestedTargets(in: context.package, for: testTarget)
        
        let targetNames = testedTargets.compactMap { $0 as? SourceModuleTarget }.map { $0.name }
        print("[QuarkTestsPlugin] Found tested targets: \(targetNames.joined(separator: ", "))")
        
        // Generate tests in the plugin's work directory
        let outputDir = context.pluginWorkDirectory.appending("GeneratedTests")
        try FileManager.default.createDirectory(at: URL(fileURLWithPath: outputDir.string), withIntermediateDirectories: true)
        
        var commands: [Command] = []
        
        // Create a test file that will import all generated tests
        let testIndexContent = generateTestIndex(for: testedTargets)
        let testIndexPath = outputDir.appending("GeneratedTestsIndex.swift")
        try testIndexContent.write(to: URL(fileURLWithPath: testIndexPath.string), atomically: true, encoding: .utf8)
        
        // Add the index file to the output files
        commands.append(
            .buildCommand(
                displayName: "Generate tests index",
                executable: .init("/bin/echo"),
                arguments: ["Generated tests index"],
                outputFiles: [testIndexPath]
            )
        )
        
        // Scan files in all tested targets
        for testedTarget in testedTargets {
            guard let sourceTarget = testedTarget as? SourceModuleTarget else { continue }
            
            print("[QuarkTestsPlugin] Scanning files in target: \(sourceTarget.name)")
            
            for file in sourceTarget.sourceFiles(withSuffix: ".swift") {
                print("[QuarkTestsPlugin] Checking file: \(file.url.path)")
                let content = try String(contentsOfFile: file.url.path)
                
                // Look for both the macro and its expanded form
                guard content.contains("@TrackPerformance") else { continue }
                
                print("[QuarkTestsPlugin] Found performance tracking in: \(file.url.lastPathComponent)")
                
                let viewName = file.url.deletingPathExtension().lastPathComponent
                let testFilePath = outputDir.appending("\(viewName)PerformanceTests.swift")
                let testContent = generateTestContent(for: viewName, target: sourceTarget.name)
                
                try testContent.write(to: URL(fileURLWithPath: testFilePath.string), atomically: true, encoding: .utf8)
                print("[QuarkTestsPlugin] Generated test: \(testFilePath.string)")
                
                // Add the generated test file to the output files
                commands.append(
                    .buildCommand(
                        displayName: "Generate performance test for \(viewName)",
                        executable: .init("/bin/echo"),
                        arguments: ["Generated test for \(viewName)"],
                        outputFiles: [testFilePath]
                    )
                )
            }
        }
        
        return commands
    }
    
    private func generateTestIndex(for targets: [Target]) -> String {
        """
        import XCTest
        import SwiftUI
        
        // This file is automatically generated by QuarkTestsPlugin
        
        // This ensures all tests are included in the test target
        final class GeneratedTestsIndex: XCTestCase {
            func testGeneratedTestsAreIncluded() {
                XCTAssertTrue(true, "This test ensures all generated tests are included in the test target")
            }
        }
        """
    }
    
    private func findTestedTargets(in package: Package, for testTarget: SourceModuleTarget) -> [Target] {
        var testedTargets: [Target] = []
        
        // Get all dependencies of the test target
        for dependency in testTarget.dependencies {
            switch dependency {
            case .target(let target):
                // Find the target in the package
                if let target = package.targets.first(where: { $0.name == target.name }) {
                    testedTargets.append(target)
                }
            case .product(let target):
                // Find the product in the package
                if let product = package.products.first(where: { $0.name == target.name }),
                   let target = package.targets.first(where: { $0.name == product.name }) {
                    testedTargets.append(target)
                }
            @unknown default:
                assertionFailure("Didn't expect to have dependency \(dependency)")
            }
        }
        
        return testedTargets
    }
    
    func generateTestContent(for viewName: String, target: String) -> String {
        """
        import XCTest
        import SwiftUI
        @testable import \(target)
        
        final class \(viewName)PerformanceTests: XCTestCase {
            typealias ViewType = \(viewName)
            var view: ViewType!
            var hostingController: UIHostingController<ViewType>!
            
            override func setUp() {
                super.setUp()
                // Initialize view with required parameters
                // Note: You may need to adjust these parameters based on your view's requirements
                view = ViewType(
                    style: .primary,
                    action: {}
                )
                hostingController = UIHostingController(rootView: view)
                _ = hostingController.view // Force view load
            }
            
            override func tearDown() {
                view = nil
                hostingController = nil
                super.tearDown()
            }
            
            func testViewInitialization() {
                XCTAssertNotNil(view, "View should be initialized")
                XCTAssertNotNil(hostingController, "Hosting controller should be initialized")
                XCTAssertNotNil(hostingController.view, "View should be loaded")
            }
            
            func testPerformanceMetadata() {
                // Access performance metadata through the view's type
                let metadata = ViewType.performanceMetadata
                XCTAssertFalse(metadata.isEmpty, "Performance metadata should not be empty")
                
                // Print metadata for debugging
                print("Performance Metadata for \(viewName):")
                for (id, info) in metadata {
                    print("- View ID: \\(id)")
                    print("  File: \\(info.file)")
                    print("  Line: \\(info.line)")
                    print("  Dependencies: \\(info.deps)")
                    print("  View Type: \\(info.viewType)")
                    print("  Is Container: \\(info.isContainer)")
                }
            }
            
            func testDependencyTracking() {
                // Access tracked dependencies through the view's type
                let dependencies = ViewType.trackedDependencies
                XCTAssertFalse(dependencies.isEmpty, "Tracked dependencies should not be empty")
                
                // Print dependencies for debugging
                print("Tracked Dependencies for \(viewName):")
                for dep in dependencies {
                    print("- \\(dep)")
                }
            }
            
            func testViewRecomputation() {
                // Reset the test context
                TestContext.shared.reset()
                
                // Get initial recomputation counts
                let initialCounts = TestContext.shared.recomputeCounts
                
                // Simulate a state change that should trigger recomputation
                // This will depend on the actual properties in your view
                if let mirror = Mirror(reflecting: view).children.first(where: { $0.label == "count" }) {
                    if var count = mirror.value as? Int {
                        count += 1
                        // Use key path to update the value
                        let keyPath = \\\\.count
                        view[keyPath: keyPath] = count
                    }
                }
                
                // Wait for UI update
                RunLoop.current.run(until: Date(timeIntervalSinceNow: 0.1))
                
                // Get new recomputation counts
                let newCounts = TestContext.shared.recomputeCounts
                
                // Verify that some views were recomputed
                XCTAssertFalse(newCounts.isEmpty, "Some views should have been recomputed")
                
                // Print recomputation details
                print("Recomputation Details for \(viewName):")
                for (viewId, info) in newCounts {
                    print("- View ID: \\(viewId)")
                    print("  File: \\(info.file)")
                    print("  Line: \\(info.line)")
                    print("  Count: \\(info.count)")
                }
            }
            
            func testUnnecessaryRecomputation() {
                // Reset the test context
                TestContext.shared.reset()
                
                // Get initial recomputation counts
                let initialCounts = TestContext.shared.recomputeCounts
                
                // Simulate a state change that should NOT trigger recomputation
                // This will depend on the actual properties in your view
                if let mirror = Mirror(reflecting: view).children.first(where: { $0.label == "isHidden" }) {
                    if var isHidden = mirror.value as? Bool {
                        isHidden.toggle()
                        // Use key path to update the value
                        let keyPath = \\\\.isHidden
                        view[keyPath: keyPath] = isHidden
                    }
                }
                
                // Wait for UI update
                RunLoop.current.run(until: Date(timeIntervalSinceNow: 0.1))
                
                // Get new recomputation counts
                let newCounts = TestContext.shared.recomputeCounts
                
                // Verify that only views depending on isHidden were recomputed
                for (viewId, info) in newCounts {
                    let expectedDeps = ViewType.performanceMetadata[viewId]?.deps ?? []
                    XCTAssertTrue(expectedDeps.contains("isHidden"), 
                                "View '\\(viewId)' at \\(info.file):\\(info.line) should only recompute when isHidden changes")
                }
            }
        }
        """
    }
}
